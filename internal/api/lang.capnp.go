// Code generated by capnpc-go. DO NOT EDIT.

package api

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Value struct{ capnp.Struct }
type Value_Which uint16

const (
	Value_Which_nil     Value_Which = 0
	Value_Which_bool    Value_Which = 1
	Value_Which_char    Value_Which = 2
	Value_Which_str     Value_Which = 3
	Value_Which_keyword Value_Which = 4
	Value_Which_symbol  Value_Which = 5
	Value_Which_path    Value_Which = 6
	Value_Which_vector  Value_Which = 7
)

func (w Value_Which) String() string {
	const s = "nilboolcharstrkeywordsymbolpathvector"
	switch w {
	case Value_Which_nil:
		return s[0:3]
	case Value_Which_bool:
		return s[3:7]
	case Value_Which_char:
		return s[7:11]
	case Value_Which_str:
		return s[11:14]
	case Value_Which_keyword:
		return s[14:21]
	case Value_Which_symbol:
		return s[21:27]
	case Value_Which_path:
		return s[27:31]
	case Value_Which_vector:
		return s[31:37]

	}
	return "Value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_TypeID is the unique identifier for the type Value.
const Value_TypeID = 0xd89c45c1f82f00a4

func NewValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value{st}, err
}

func NewRootValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value{st}, err
}

func ReadRootValue(msg *capnp.Message) (Value, error) {
	root, err := msg.RootPtr()
	return Value{root.Struct()}, err
}

func (s Value) String() string {
	str, _ := text.Marshal(0xd89c45c1f82f00a4, s.Struct)
	return str
}

func (s Value) Which() Value_Which {
	return Value_Which(s.Struct.Uint16(0))
}
func (s Value) SetNil() {
	s.Struct.SetUint16(0, 0)

}

func (s Value) Bool() bool {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != bool")
	}
	return s.Struct.Bit(16)
}

func (s Value) SetBool(v bool) {
	s.Struct.SetUint16(0, 1)
	s.Struct.SetBit(16, v)
}

func (s Value) Char() int32 {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != char")
	}
	return int32(s.Struct.Uint32(4))
}

func (s Value) SetChar(v int32) {
	s.Struct.SetUint16(0, 2)
	s.Struct.SetUint32(4, uint32(v))
}

func (s Value) Str() (string, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != str")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasStr() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Value) StrBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetStr(v string) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetText(0, v)
}

func (s Value) Keyword() (string, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != keyword")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasKeyword() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Value) KeywordBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetKeyword(v string) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetText(0, v)
}

func (s Value) Symbol() (string, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != symbol")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasSymbol() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Value) SymbolBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetSymbol(v string) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetText(0, v)
}

func (s Value) Path() (string, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != path")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasPath() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Value) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetPath(v string) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetText(0, v)
}

func (s Value) Vector() (Vector, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != vector")
	}
	p, err := s.Struct.Ptr(0)
	return Vector{Struct: p.Struct()}, err
}

func (s Value) HasVector() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Value) SetVector(v Vector) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVector sets the vector field to a newly
// allocated Vector struct, preferring placement in s's segment.
func (s Value) NewVector() (Vector, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewVector(s.Struct.Segment())
	if err != nil {
		return Vector{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Value_List is a list of Value.
type Value_List struct{ capnp.List }

// NewValue creates a new list of Value.
func NewValue_List(s *capnp.Segment, sz int32) (Value_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Value_List{l}, err
}

func (s Value_List) At(i int) Value { return Value{s.List.Struct(i)} }

func (s Value_List) Set(i int, v Value) error { return s.List.SetStruct(i, v.Struct) }

func (s Value_List) String() string {
	str, _ := text.MarshalList(0xd89c45c1f82f00a4, s.List)
	return str
}

// Value_Promise is a wrapper for a Value promised by a client call.
type Value_Promise struct{ *capnp.Pipeline }

func (p Value_Promise) Struct() (Value, error) {
	s, err := p.Pipeline.Struct()
	return Value{s}, err
}

func (p Value_Promise) Vector() Vector_Promise {
	return Vector_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Vector struct{ capnp.Struct }

// Vector_TypeID is the unique identifier for the type Vector.
const Vector_TypeID = 0xf43c9c7fd25a0b43

func NewVector(s *capnp.Segment) (Vector, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Vector{st}, err
}

func NewRootVector(s *capnp.Segment) (Vector, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Vector{st}, err
}

func ReadRootVector(msg *capnp.Message) (Vector, error) {
	root, err := msg.RootPtr()
	return Vector{root.Struct()}, err
}

func (s Vector) String() string {
	str, _ := text.Marshal(0xf43c9c7fd25a0b43, s.Struct)
	return str
}

func (s Vector) Count() uint32 {
	return s.Struct.Uint32(0)
}

func (s Vector) SetCount(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s Vector) Shift() uint8 {
	return s.Struct.Uint8(4)
}

func (s Vector) SetShift(v uint8) {
	s.Struct.SetUint8(4, v)
}

func (s Vector) Root() (Vector_Node, error) {
	p, err := s.Struct.Ptr(0)
	return Vector_Node{Struct: p.Struct()}, err
}

func (s Vector) HasRoot() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Vector) SetRoot(v Vector_Node) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRoot sets the root field to a newly
// allocated Vector_Node struct, preferring placement in s's segment.
func (s Vector) NewRoot() (Vector_Node, error) {
	ss, err := NewVector_Node(s.Struct.Segment())
	if err != nil {
		return Vector_Node{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Vector) Tail() (Value_List, error) {
	p, err := s.Struct.Ptr(1)
	return Value_List{List: p.List()}, err
}

func (s Vector) HasTail() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Vector) SetTail(v Value_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewTail sets the tail field to a newly
// allocated Value_List, preferring placement in s's segment.
func (s Vector) NewTail(n int32) (Value_List, error) {
	l, err := NewValue_List(s.Struct.Segment(), n)
	if err != nil {
		return Value_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Vector_List is a list of Vector.
type Vector_List struct{ capnp.List }

// NewVector creates a new list of Vector.
func NewVector_List(s *capnp.Segment, sz int32) (Vector_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Vector_List{l}, err
}

func (s Vector_List) At(i int) Vector { return Vector{s.List.Struct(i)} }

func (s Vector_List) Set(i int, v Vector) error { return s.List.SetStruct(i, v.Struct) }

func (s Vector_List) String() string {
	str, _ := text.MarshalList(0xf43c9c7fd25a0b43, s.List)
	return str
}

// Vector_Promise is a wrapper for a Vector promised by a client call.
type Vector_Promise struct{ *capnp.Pipeline }

func (p Vector_Promise) Struct() (Vector, error) {
	s, err := p.Pipeline.Struct()
	return Vector{s}, err
}

func (p Vector_Promise) Root() Vector_Node_Promise {
	return Vector_Node_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Vector_Node struct{ capnp.Struct }
type Vector_Node_Which uint16

const (
	Vector_Node_Which_branches Vector_Node_Which = 0
	Vector_Node_Which_values   Vector_Node_Which = 1
)

func (w Vector_Node_Which) String() string {
	const s = "branchesvalues"
	switch w {
	case Vector_Node_Which_branches:
		return s[0:8]
	case Vector_Node_Which_values:
		return s[8:14]

	}
	return "Vector_Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Vector_Node_TypeID is the unique identifier for the type Vector_Node.
const Vector_Node_TypeID = 0x917e2c3a50b433f0

func NewVector_Node(s *capnp.Segment) (Vector_Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Vector_Node{st}, err
}

func NewRootVector_Node(s *capnp.Segment) (Vector_Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Vector_Node{st}, err
}

func ReadRootVector_Node(msg *capnp.Message) (Vector_Node, error) {
	root, err := msg.RootPtr()
	return Vector_Node{root.Struct()}, err
}

func (s Vector_Node) String() string {
	str, _ := text.Marshal(0x917e2c3a50b433f0, s.Struct)
	return str
}

func (s Vector_Node) Which() Vector_Node_Which {
	return Vector_Node_Which(s.Struct.Uint16(0))
}
func (s Vector_Node) Branches() (Vector_Node_List, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != branches")
	}
	p, err := s.Struct.Ptr(0)
	return Vector_Node_List{List: p.List()}, err
}

func (s Vector_Node) HasBranches() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Vector_Node) SetBranches(v Vector_Node_List) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewBranches sets the branches field to a newly
// allocated Vector_Node_List, preferring placement in s's segment.
func (s Vector_Node) NewBranches(n int32) (Vector_Node_List, error) {
	s.Struct.SetUint16(0, 0)
	l, err := NewVector_Node_List(s.Struct.Segment(), n)
	if err != nil {
		return Vector_Node_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Vector_Node) Values() (Value_List, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != values")
	}
	p, err := s.Struct.Ptr(0)
	return Value_List{List: p.List()}, err
}

func (s Vector_Node) HasValues() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Vector_Node) SetValues(v Value_List) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewValues sets the values field to a newly
// allocated Value_List, preferring placement in s's segment.
func (s Vector_Node) NewValues(n int32) (Value_List, error) {
	s.Struct.SetUint16(0, 1)
	l, err := NewValue_List(s.Struct.Segment(), n)
	if err != nil {
		return Value_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Vector_Node_List is a list of Vector_Node.
type Vector_Node_List struct{ capnp.List }

// NewVector_Node creates a new list of Vector_Node.
func NewVector_Node_List(s *capnp.Segment, sz int32) (Vector_Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Vector_Node_List{l}, err
}

func (s Vector_Node_List) At(i int) Vector_Node { return Vector_Node{s.List.Struct(i)} }

func (s Vector_Node_List) Set(i int, v Vector_Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Vector_Node_List) String() string {
	str, _ := text.MarshalList(0x917e2c3a50b433f0, s.List)
	return str
}

// Vector_Node_Promise is a wrapper for a Vector_Node promised by a client call.
type Vector_Node_Promise struct{ *capnp.Pipeline }

func (p Vector_Node_Promise) Struct() (Vector_Node, error) {
	s, err := p.Pipeline.Struct()
	return Vector_Node{s}, err
}

const schema_e7dd644ba93cb72c = "x\xdatR\xcfK\x14a\x18~\x9e\xf7\x9b\xddYh" +
	"\xb7\xd9\xc1!Obt*\x11\xcd\xba\x89`\xbf\xbc\x14" +
	"\x88\xdf%\":4\xeeN\xed\xd2\xb8\xb3\xec\x8e\x8a\x97" +
	"\xbc\xf4\x0ft\xf7\xd8\xa5\x8e\x11t\xea\xd0!\xba\x14T" +
	"\x14X(\x18\x18\x1a\x14x0\xd0J\xbf\xf8\\v\xb7" +
	"\xa2\x8e\xef\xf3>\xbc<?\xde\x93\xbd<##\x19\x8f" +
	"\x80\xceg\xb2f\xeb\xf4\xa3\xa9\xd1\xc1\xdbw\xa1\x8f\x90" +
	"\xe6\xfc\xa1\xabo\x16\x97\xc6\xb61AW\x00\x7f\xe6\x83" +
	"\xbf\xe0\x02\xfe\xec<\xb8wox\xe7\xe9\xc4\xd2\xb2\xf6" +
	"H3\xf8x\xec\xfe\xa5\xf2\xea\x86%\xe6\x00\xff\xdb\x03" +
	"\x7f\xcf\x05Fv\x9f\x13\xbf\x9d\xf9\x93\x9b\x11\x17\xe8y" +
	"\"\x0f{\x9eI/\xd0\xf3R6@\x13\xd6\xab\xc3q" +
	"X\xbb)C\xa5\xb0^\xab\x8f^\x8eJi\xd2\x18\x9a" +
	"LT9\x9a\"uN9yc\x1c\x02\xfe\x89\x8b\x80" +
	">\xae\xa8/\x08\x0b\xdc7\x01-zv\x14\xd0c\x8a" +
	"\xfa\x8a\xd0L7\xc2Z\xa9\x125\x01\xf008\xa5\xc8" +
	"b\xd7$h\xc1\xf1\xb90\x9e\x8d\x9a\x9d}\xdbYk" +
	"\xdb\x11\xc4\xb6 \xcf\xd2\xad\x94\xa3])\xaf\x8f\x01\xfa" +
	"\x85\xa2^\x16\xf6q\xdf\x14[Z\xde\x0d\x00\xfa\x95\xa2" +
	"^\x11\xf6\xc9\x9ea@\x9b\xe3{\x0b\xbfU\xd4k\xc2" +
	"\x82\xfai\x02*\xc0_\xb57\x96\x15\xf5\xba\xb0\xe0\xfc" +
	"0\x01\x1d\xc0\xffx\x0e\xd0+\x8azSX\xc8|7" +
	"\x013\x80\xff\xc9\x9a\\S\xd4_\x84\x85\xec\xae\x09\x98" +
	"\x05\xfc\xcf\xf6\xee\xba\xa2\xde\x12\x16\xdc\x1d\x13\xd0\xb6\xf5" +
	"\xd5r7\x15\xf5\xb6\xd0\xadUcd\xbd\xe9$\x89I" +
	"\x08\x09z\xa5J\xd8\xa0\x03\xa1\x03\xba\xcd\xb4\xc1<\x84" +
	"yp\xf1V\xb40\x9f4\xca\xedy\xbc\xb903\x9d" +
	"\xc4\xed\xd1\xab\x87i\xa5\xb3\x9b;\xa8\x89\xc5n\xd9 " +
	"\x8b\xff\x8a\xaf\xff\x80\xa9\x1d\xb2[\x84\xcf\x01o2)" +
	"G\xba\xa8\x1c\xe0 \xd1\xf0\x14\xa0\xaf)\xea\x8a\xd0\xa7" +
	"\xd3\xca3\xb2\xe0uE\x1d\x0b)\xad0\xab\xd6tY" +
	"Q\xd7\x85\xbeb+\xcb\x19\x0bV\x14\xf5\x1da\x7f)" +
	"\x99\xad\xa5\xccA\x98\x03\xfb\x9b\x95\xea\x8d\x94Y\x08\xb3" +
	"\xa0\xd7H\x92\xf4\xaf\x97(\x82^\x1aV\xe3\xff<\xc4" +
	"\xaf\x00\x00\x00\xff\xff\x82\x15\xcb\x0a"

func init() {
	schemas.Register(schema_e7dd644ba93cb72c,
		0x917e2c3a50b433f0,
		0xd89c45c1f82f00a4,
		0xf43c9c7fd25a0b43)
}
