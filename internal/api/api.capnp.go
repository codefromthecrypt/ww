// Code generated by capnpc-go. DO NOT EDIT.

package api

import (
	context "context"
	math "math"
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
	server "zombiezen.com/go/capnproto2/server"
)

type Value struct{ capnp.Struct }
type Value_Which uint16

const (
	Value_Which_nil      Value_Which = 0
	Value_Which_native   Value_Which = 1
	Value_Which_bool     Value_Which = 2
	Value_Which_i64      Value_Which = 3
	Value_Which_bigInt   Value_Which = 4
	Value_Which_f64      Value_Which = 5
	Value_Which_bigFloat Value_Which = 6
	Value_Which_frac     Value_Which = 7
	Value_Which_char     Value_Which = 8
	Value_Which_str      Value_Which = 9
	Value_Which_keyword  Value_Which = 10
	Value_Which_symbol   Value_Which = 11
	Value_Which_path     Value_Which = 12
	Value_Which_list     Value_Which = 13
	Value_Which_vector   Value_Which = 14
	Value_Which_proc     Value_Which = 15
)

func (w Value_Which) String() string {
	const s = "nilnativebooli64bigIntf64bigFloatfraccharstrkeywordsymbolpathlistvectorproc"
	switch w {
	case Value_Which_nil:
		return s[0:3]
	case Value_Which_native:
		return s[3:9]
	case Value_Which_bool:
		return s[9:13]
	case Value_Which_i64:
		return s[13:16]
	case Value_Which_bigInt:
		return s[16:22]
	case Value_Which_f64:
		return s[22:25]
	case Value_Which_bigFloat:
		return s[25:33]
	case Value_Which_frac:
		return s[33:37]
	case Value_Which_char:
		return s[37:41]
	case Value_Which_str:
		return s[41:44]
	case Value_Which_keyword:
		return s[44:51]
	case Value_Which_symbol:
		return s[51:57]
	case Value_Which_path:
		return s[57:61]
	case Value_Which_list:
		return s[61:65]
	case Value_Which_vector:
		return s[65:71]
	case Value_Which_proc:
		return s[71:75]

	}
	return "Value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_TypeID is the unique identifier for the type Value.
const Value_TypeID = 0xba39aaea7d7bcba2

func NewValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Value{st}, err
}

func NewRootValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Value{st}, err
}

func ReadRootValue(msg *capnp.Message) (Value, error) {
	root, err := msg.Root()
	return Value{root.Struct()}, err
}

func (s Value) String() string {
	str, _ := text.Marshal(0xba39aaea7d7bcba2, s.Struct)
	return str
}

func (s Value) Which() Value_Which {
	return Value_Which(s.Struct.Uint16(0))
}
func (s Value) SetNil() {
	s.Struct.SetUint16(0, 0)

}

func (s Value) Native() (string, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != native")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasNative() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) NativeBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetNative(v string) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetText(0, v)
}

func (s Value) Bool() bool {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != bool")
	}
	return s.Struct.Bit(16)
}

func (s Value) SetBool(v bool) {
	s.Struct.SetUint16(0, 2)
	s.Struct.SetBit(16, v)
}

func (s Value) I64() int64 {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != i64")
	}
	return int64(s.Struct.Uint64(8))
}

func (s Value) SetI64(v int64) {
	s.Struct.SetUint16(0, 3)
	s.Struct.SetUint64(8, uint64(v))
}

func (s Value) BigInt() ([]byte, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != bigInt")
	}
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Value) HasBigInt() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SetBigInt(v []byte) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetData(0, v)
}

func (s Value) F64() float64 {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != f64")
	}
	return math.Float64frombits(s.Struct.Uint64(8))
}

func (s Value) SetF64(v float64) {
	s.Struct.SetUint16(0, 5)
	s.Struct.SetUint64(8, math.Float64bits(v))
}

func (s Value) BigFloat() (string, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != bigFloat")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasBigFloat() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) BigFloatBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetBigFloat(v string) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetText(0, v)
}

func (s Value) Frac() (Frac, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != frac")
	}
	p, err := s.Struct.Ptr(0)
	return Frac{Struct: p.Struct()}, err
}

func (s Value) HasFrac() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SetFrac(v Frac) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrac sets the frac field to a newly
// allocated Frac struct, preferring placement in s's segment.
func (s Value) NewFrac() (Frac, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewFrac(s.Struct.Segment())
	if err != nil {
		return Frac{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Value) Char() int32 {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != char")
	}
	return int32(s.Struct.Uint32(8))
}

func (s Value) SetChar(v int32) {
	s.Struct.SetUint16(0, 8)
	s.Struct.SetUint32(8, uint32(v))
}

func (s Value) Str() (string, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != str")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasStr() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) StrBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetStr(v string) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetText(0, v)
}

func (s Value) Keyword() (string, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != keyword")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasKeyword() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) KeywordBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetKeyword(v string) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetText(0, v)
}

func (s Value) Symbol() (string, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != symbol")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasSymbol() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SymbolBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetSymbol(v string) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetText(0, v)
}

func (s Value) Path() (string, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != path")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Value) HasPath() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetPath(v string) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetText(0, v)
}

func (s Value) List() (LinkedList, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != list")
	}
	p, err := s.Struct.Ptr(0)
	return LinkedList{Struct: p.Struct()}, err
}

func (s Value) HasList() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SetList(v LinkedList) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated LinkedList struct, preferring placement in s's segment.
func (s Value) NewList() (LinkedList, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewLinkedList(s.Struct.Segment())
	if err != nil {
		return LinkedList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Value) Vector() (Vector, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != vector")
	}
	p, err := s.Struct.Ptr(0)
	return Vector{Struct: p.Struct()}, err
}

func (s Value) HasVector() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SetVector(v Vector) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVector sets the vector field to a newly
// allocated Vector struct, preferring placement in s's segment.
func (s Value) NewVector() (Vector, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewVector(s.Struct.Segment())
	if err != nil {
		return Vector{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Value) Proc() Proc {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != proc")
	}
	p, _ := s.Struct.Ptr(0)
	return Proc{Client: p.Interface().Client()}
}

func (s Value) HasProc() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Value) SetProc(v Proc) error {
	s.Struct.SetUint16(0, 15)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Value_List is a list of Value.
type Value_List struct{ capnp.List }

// NewValue creates a new list of Value.
func NewValue_List(s *capnp.Segment, sz int32) (Value_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return Value_List{l}, err
}

func (s Value_List) At(i int) Value { return Value{s.List.Struct(i)} }

func (s Value_List) Set(i int, v Value) error { return s.List.SetStruct(i, v.Struct) }

func (s Value_List) String() string {
	str, _ := text.MarshalList(0xba39aaea7d7bcba2, s.List)
	return str
}

// Value_Future is a wrapper for a Value promised by a client call.
type Value_Future struct{ *capnp.Future }

func (p Value_Future) Struct() (Value, error) {
	s, err := p.Future.Struct()
	return Value{s}, err
}

func (p Value_Future) Frac() Frac_Future {
	return Frac_Future{Future: p.Future.Field(0, nil)}
}

func (p Value_Future) List() LinkedList_Future {
	return LinkedList_Future{Future: p.Future.Field(0, nil)}
}

func (p Value_Future) Vector() Vector_Future {
	return Vector_Future{Future: p.Future.Field(0, nil)}
}

func (p Value_Future) Proc() Proc {
	return Proc{Client: p.Future.Field(0, nil).Client()}
}

type Anchor struct{ Client *capnp.Client }

// Anchor_TypeID is the unique identifier for the type Anchor.
const Anchor_TypeID = 0xf4acba02cd83d452

func (c Anchor) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      0,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      1,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Load(ctx context.Context, params func(Anchor_load_Params) error) (Anchor_load_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      2,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "load",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_load_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_load_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Store(ctx context.Context, params func(Anchor_store_Params) error) (Anchor_store_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      3,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "store",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_store_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_store_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Go(ctx context.Context, params func(Anchor_go_Params) error) (Anchor_go_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      4,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "go",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_go_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_go_Results_Future{Future: ans.Future()}, release
}

// A Anchor_Server is a Anchor with a local implementation.
type Anchor_Server interface {
	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error

	Load(context.Context, Anchor_load) error

	Store(context.Context, Anchor_store) error

	Go(context.Context, Anchor_go) error
}

// Anchor_NewServer creates a new Server from an implementation of Anchor_Server.
func Anchor_NewServer(s Anchor_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Anchor_Methods(nil, s), s, c, policy)
}

// Anchor_ServerToClient creates a new Client from an implementation of Anchor_Server.
// The caller is responsible for calling Release on the returned Client.
func Anchor_ServerToClient(s Anchor_Server, policy *server.Policy) Anchor {
	return Anchor{Client: capnp.NewClient(Anchor_NewServer(s, policy))}
}

// Anchor_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Anchor_Methods(methods []server.Method, s Anchor_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 5)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      0,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      1,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      2,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "load",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Load(ctx, Anchor_load{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      3,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "store",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Store(ctx, Anchor_store{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf4acba02cd83d452,
			MethodID:      4,
			InterfaceName: "api/api.capnp:Anchor",
			MethodName:    "go",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Go(ctx, Anchor_go{call})
		},
	})

	return methods
}

// Anchor_ls holds the state for a server call to Anchor.ls.
// See server.Call for documentation.
type Anchor_ls struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_ls) Args() Anchor_ls_Params {
	return Anchor_ls_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_ls) AllocResults() (Anchor_ls_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{Struct: r}, err
}

// Anchor_walk holds the state for a server call to Anchor.walk.
// See server.Call for documentation.
type Anchor_walk struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_walk) Args() Anchor_walk_Params {
	return Anchor_walk_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_walk) AllocResults() (Anchor_walk_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{Struct: r}, err
}

// Anchor_load holds the state for a server call to Anchor.load.
// See server.Call for documentation.
type Anchor_load struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_load) Args() Anchor_load_Params {
	return Anchor_load_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_load) AllocResults() (Anchor_load_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_load_Results{Struct: r}, err
}

// Anchor_store holds the state for a server call to Anchor.store.
// See server.Call for documentation.
type Anchor_store struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_store) Args() Anchor_store_Params {
	return Anchor_store_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_store) AllocResults() (Anchor_store_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_store_Results{Struct: r}, err
}

// Anchor_go holds the state for a server call to Anchor.go.
// See server.Call for documentation.
type Anchor_go struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_go) Args() Anchor_go_Params {
	return Anchor_go_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_go) AllocResults() (Anchor_go_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_go_Results{Struct: r}, err
}

type Anchor_SubAnchor struct{ capnp.Struct }
type Anchor_SubAnchor_Which uint16

const (
	Anchor_SubAnchor_Which_root   Anchor_SubAnchor_Which = 0
	Anchor_SubAnchor_Which_anchor Anchor_SubAnchor_Which = 1
)

func (w Anchor_SubAnchor_Which) String() string {
	const s = "rootanchor"
	switch w {
	case Anchor_SubAnchor_Which_root:
		return s[0:4]
	case Anchor_SubAnchor_Which_anchor:
		return s[4:10]

	}
	return "Anchor_SubAnchor_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Anchor_SubAnchor_TypeID is the unique identifier for the type Anchor_SubAnchor.
const Anchor_SubAnchor_TypeID = 0xea2bd670e2878d2d

func NewAnchor_SubAnchor(s *capnp.Segment) (Anchor_SubAnchor, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Anchor_SubAnchor{st}, err
}

func NewRootAnchor_SubAnchor(s *capnp.Segment) (Anchor_SubAnchor, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Anchor_SubAnchor{st}, err
}

func ReadRootAnchor_SubAnchor(msg *capnp.Message) (Anchor_SubAnchor, error) {
	root, err := msg.Root()
	return Anchor_SubAnchor{root.Struct()}, err
}

func (s Anchor_SubAnchor) String() string {
	str, _ := text.Marshal(0xea2bd670e2878d2d, s.Struct)
	return str
}

func (s Anchor_SubAnchor) Which() Anchor_SubAnchor_Which {
	return Anchor_SubAnchor_Which(s.Struct.Uint16(0))
}
func (s Anchor_SubAnchor) Path() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Anchor_SubAnchor) HasPath() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_SubAnchor) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Anchor_SubAnchor) SetPath(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Anchor_SubAnchor) SetRoot() {
	s.Struct.SetUint16(0, 0)

}

func (s Anchor_SubAnchor) Anchor() Anchor {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != anchor")
	}
	p, _ := s.Struct.Ptr(1)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_SubAnchor) HasAnchor() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(1)
}

func (s Anchor_SubAnchor) SetAnchor(v Anchor) error {
	s.Struct.SetUint16(0, 1)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(1, in.ToPtr())
}

// Anchor_SubAnchor_List is a list of Anchor_SubAnchor.
type Anchor_SubAnchor_List struct{ capnp.List }

// NewAnchor_SubAnchor creates a new list of Anchor_SubAnchor.
func NewAnchor_SubAnchor_List(s *capnp.Segment, sz int32) (Anchor_SubAnchor_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Anchor_SubAnchor_List{l}, err
}

func (s Anchor_SubAnchor_List) At(i int) Anchor_SubAnchor { return Anchor_SubAnchor{s.List.Struct(i)} }

func (s Anchor_SubAnchor_List) Set(i int, v Anchor_SubAnchor) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_SubAnchor_List) String() string {
	str, _ := text.MarshalList(0xea2bd670e2878d2d, s.List)
	return str
}

// Anchor_SubAnchor_Future is a wrapper for a Anchor_SubAnchor promised by a client call.
type Anchor_SubAnchor_Future struct{ *capnp.Future }

func (p Anchor_SubAnchor_Future) Struct() (Anchor_SubAnchor, error) {
	s, err := p.Future.Struct()
	return Anchor_SubAnchor{s}, err
}

func (p Anchor_SubAnchor_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(1, nil).Client()}
}

type Anchor_ls_Params struct{ capnp.Struct }

// Anchor_ls_Params_TypeID is the unique identifier for the type Anchor_ls_Params.
const Anchor_ls_Params_TypeID = 0xef56981b53fef997

func NewAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_ls_Params{st}, err
}

func NewRootAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_ls_Params{st}, err
}

func ReadRootAnchor_ls_Params(msg *capnp.Message) (Anchor_ls_Params, error) {
	root, err := msg.Root()
	return Anchor_ls_Params{root.Struct()}, err
}

func (s Anchor_ls_Params) String() string {
	str, _ := text.Marshal(0xef56981b53fef997, s.Struct)
	return str
}

// Anchor_ls_Params_List is a list of Anchor_ls_Params.
type Anchor_ls_Params_List struct{ capnp.List }

// NewAnchor_ls_Params creates a new list of Anchor_ls_Params.
func NewAnchor_ls_Params_List(s *capnp.Segment, sz int32) (Anchor_ls_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Anchor_ls_Params_List{l}, err
}

func (s Anchor_ls_Params_List) At(i int) Anchor_ls_Params { return Anchor_ls_Params{s.List.Struct(i)} }

func (s Anchor_ls_Params_List) Set(i int, v Anchor_ls_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_ls_Params_List) String() string {
	str, _ := text.MarshalList(0xef56981b53fef997, s.List)
	return str
}

// Anchor_ls_Params_Future is a wrapper for a Anchor_ls_Params promised by a client call.
type Anchor_ls_Params_Future struct{ *capnp.Future }

func (p Anchor_ls_Params_Future) Struct() (Anchor_ls_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Params{s}, err
}

type Anchor_ls_Results struct{ capnp.Struct }

// Anchor_ls_Results_TypeID is the unique identifier for the type Anchor_ls_Results.
const Anchor_ls_Results_TypeID = 0xc2241b810eb3f099

func NewAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func NewRootAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func ReadRootAnchor_ls_Results(msg *capnp.Message) (Anchor_ls_Results, error) {
	root, err := msg.Root()
	return Anchor_ls_Results{root.Struct()}, err
}

func (s Anchor_ls_Results) String() string {
	str, _ := text.Marshal(0xc2241b810eb3f099, s.Struct)
	return str
}

func (s Anchor_ls_Results) Children() (Anchor_SubAnchor_List, error) {
	p, err := s.Struct.Ptr(0)
	return Anchor_SubAnchor_List{List: p.List()}, err
}

func (s Anchor_ls_Results) HasChildren() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_ls_Results) SetChildren(v Anchor_SubAnchor_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated Anchor_SubAnchor_List, preferring placement in s's segment.
func (s Anchor_ls_Results) NewChildren(n int32) (Anchor_SubAnchor_List, error) {
	l, err := NewAnchor_SubAnchor_List(s.Struct.Segment(), n)
	if err != nil {
		return Anchor_SubAnchor_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_ls_Results_List is a list of Anchor_ls_Results.
type Anchor_ls_Results_List struct{ capnp.List }

// NewAnchor_ls_Results creates a new list of Anchor_ls_Results.
func NewAnchor_ls_Results_List(s *capnp.Segment, sz int32) (Anchor_ls_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_ls_Results_List{l}, err
}

func (s Anchor_ls_Results_List) At(i int) Anchor_ls_Results {
	return Anchor_ls_Results{s.List.Struct(i)}
}

func (s Anchor_ls_Results_List) Set(i int, v Anchor_ls_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_ls_Results_List) String() string {
	str, _ := text.MarshalList(0xc2241b810eb3f099, s.List)
	return str
}

// Anchor_ls_Results_Future is a wrapper for a Anchor_ls_Results promised by a client call.
type Anchor_ls_Results_Future struct{ *capnp.Future }

func (p Anchor_ls_Results_Future) Struct() (Anchor_ls_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Results{s}, err
}

type Anchor_walk_Params struct{ capnp.Struct }

// Anchor_walk_Params_TypeID is the unique identifier for the type Anchor_walk_Params.
const Anchor_walk_Params_TypeID = 0xb1fcf692a8c62e19

func NewAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func NewRootAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func ReadRootAnchor_walk_Params(msg *capnp.Message) (Anchor_walk_Params, error) {
	root, err := msg.Root()
	return Anchor_walk_Params{root.Struct()}, err
}

func (s Anchor_walk_Params) String() string {
	str, _ := text.Marshal(0xb1fcf692a8c62e19, s.Struct)
	return str
}

func (s Anchor_walk_Params) Path() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Anchor_walk_Params) HasPath() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Params) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Anchor_walk_Params) SetPath(v string) error {
	return s.Struct.SetText(0, v)
}

// Anchor_walk_Params_List is a list of Anchor_walk_Params.
type Anchor_walk_Params_List struct{ capnp.List }

// NewAnchor_walk_Params creates a new list of Anchor_walk_Params.
func NewAnchor_walk_Params_List(s *capnp.Segment, sz int32) (Anchor_walk_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_walk_Params_List{l}, err
}

func (s Anchor_walk_Params_List) At(i int) Anchor_walk_Params {
	return Anchor_walk_Params{s.List.Struct(i)}
}

func (s Anchor_walk_Params_List) Set(i int, v Anchor_walk_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_walk_Params_List) String() string {
	str, _ := text.MarshalList(0xb1fcf692a8c62e19, s.List)
	return str
}

// Anchor_walk_Params_Future is a wrapper for a Anchor_walk_Params promised by a client call.
type Anchor_walk_Params_Future struct{ *capnp.Future }

func (p Anchor_walk_Params_Future) Struct() (Anchor_walk_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Params{s}, err
}

type Anchor_walk_Results struct{ capnp.Struct }

// Anchor_walk_Results_TypeID is the unique identifier for the type Anchor_walk_Results.
const Anchor_walk_Results_TypeID = 0x95460e1858f85cf4

func NewAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func NewRootAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func ReadRootAnchor_walk_Results(msg *capnp.Message) (Anchor_walk_Results, error) {
	root, err := msg.Root()
	return Anchor_walk_Results{root.Struct()}, err
}

func (s Anchor_walk_Results) String() string {
	str, _ := text.Marshal(0x95460e1858f85cf4, s.Struct)
	return str
}

func (s Anchor_walk_Results) Anchor() Anchor {
	p, _ := s.Struct.Ptr(0)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_walk_Results) HasAnchor() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Results) SetAnchor(v Anchor) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Anchor_walk_Results_List is a list of Anchor_walk_Results.
type Anchor_walk_Results_List struct{ capnp.List }

// NewAnchor_walk_Results creates a new list of Anchor_walk_Results.
func NewAnchor_walk_Results_List(s *capnp.Segment, sz int32) (Anchor_walk_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_walk_Results_List{l}, err
}

func (s Anchor_walk_Results_List) At(i int) Anchor_walk_Results {
	return Anchor_walk_Results{s.List.Struct(i)}
}

func (s Anchor_walk_Results_List) Set(i int, v Anchor_walk_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_walk_Results_List) String() string {
	str, _ := text.MarshalList(0x95460e1858f85cf4, s.List)
	return str
}

// Anchor_walk_Results_Future is a wrapper for a Anchor_walk_Results promised by a client call.
type Anchor_walk_Results_Future struct{ *capnp.Future }

func (p Anchor_walk_Results_Future) Struct() (Anchor_walk_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Results{s}, err
}

func (p Anchor_walk_Results_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(0, nil).Client()}
}

type Anchor_load_Params struct{ capnp.Struct }

// Anchor_load_Params_TypeID is the unique identifier for the type Anchor_load_Params.
const Anchor_load_Params_TypeID = 0xa94cf75566fcc440

func NewAnchor_load_Params(s *capnp.Segment) (Anchor_load_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_load_Params{st}, err
}

func NewRootAnchor_load_Params(s *capnp.Segment) (Anchor_load_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_load_Params{st}, err
}

func ReadRootAnchor_load_Params(msg *capnp.Message) (Anchor_load_Params, error) {
	root, err := msg.Root()
	return Anchor_load_Params{root.Struct()}, err
}

func (s Anchor_load_Params) String() string {
	str, _ := text.Marshal(0xa94cf75566fcc440, s.Struct)
	return str
}

// Anchor_load_Params_List is a list of Anchor_load_Params.
type Anchor_load_Params_List struct{ capnp.List }

// NewAnchor_load_Params creates a new list of Anchor_load_Params.
func NewAnchor_load_Params_List(s *capnp.Segment, sz int32) (Anchor_load_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Anchor_load_Params_List{l}, err
}

func (s Anchor_load_Params_List) At(i int) Anchor_load_Params {
	return Anchor_load_Params{s.List.Struct(i)}
}

func (s Anchor_load_Params_List) Set(i int, v Anchor_load_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_load_Params_List) String() string {
	str, _ := text.MarshalList(0xa94cf75566fcc440, s.List)
	return str
}

// Anchor_load_Params_Future is a wrapper for a Anchor_load_Params promised by a client call.
type Anchor_load_Params_Future struct{ *capnp.Future }

func (p Anchor_load_Params_Future) Struct() (Anchor_load_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_load_Params{s}, err
}

type Anchor_load_Results struct{ capnp.Struct }

// Anchor_load_Results_TypeID is the unique identifier for the type Anchor_load_Results.
const Anchor_load_Results_TypeID = 0xb3012e36a35e0fb0

func NewAnchor_load_Results(s *capnp.Segment) (Anchor_load_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_load_Results{st}, err
}

func NewRootAnchor_load_Results(s *capnp.Segment) (Anchor_load_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_load_Results{st}, err
}

func ReadRootAnchor_load_Results(msg *capnp.Message) (Anchor_load_Results, error) {
	root, err := msg.Root()
	return Anchor_load_Results{root.Struct()}, err
}

func (s Anchor_load_Results) String() string {
	str, _ := text.Marshal(0xb3012e36a35e0fb0, s.Struct)
	return str
}

func (s Anchor_load_Results) Value() (Value, error) {
	p, err := s.Struct.Ptr(0)
	return Value{Struct: p.Struct()}, err
}

func (s Anchor_load_Results) HasValue() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_load_Results) SetValue(v Value) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewValue sets the value field to a newly
// allocated Value struct, preferring placement in s's segment.
func (s Anchor_load_Results) NewValue() (Value, error) {
	ss, err := NewValue(s.Struct.Segment())
	if err != nil {
		return Value{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Anchor_load_Results_List is a list of Anchor_load_Results.
type Anchor_load_Results_List struct{ capnp.List }

// NewAnchor_load_Results creates a new list of Anchor_load_Results.
func NewAnchor_load_Results_List(s *capnp.Segment, sz int32) (Anchor_load_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_load_Results_List{l}, err
}

func (s Anchor_load_Results_List) At(i int) Anchor_load_Results {
	return Anchor_load_Results{s.List.Struct(i)}
}

func (s Anchor_load_Results_List) Set(i int, v Anchor_load_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_load_Results_List) String() string {
	str, _ := text.MarshalList(0xb3012e36a35e0fb0, s.List)
	return str
}

// Anchor_load_Results_Future is a wrapper for a Anchor_load_Results promised by a client call.
type Anchor_load_Results_Future struct{ *capnp.Future }

func (p Anchor_load_Results_Future) Struct() (Anchor_load_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_load_Results{s}, err
}

func (p Anchor_load_Results_Future) Value() Value_Future {
	return Value_Future{Future: p.Future.Field(0, nil)}
}

type Anchor_store_Params struct{ capnp.Struct }

// Anchor_store_Params_TypeID is the unique identifier for the type Anchor_store_Params.
const Anchor_store_Params_TypeID = 0x8ef1ac844ec73672

func NewAnchor_store_Params(s *capnp.Segment) (Anchor_store_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_store_Params{st}, err
}

func NewRootAnchor_store_Params(s *capnp.Segment) (Anchor_store_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_store_Params{st}, err
}

func ReadRootAnchor_store_Params(msg *capnp.Message) (Anchor_store_Params, error) {
	root, err := msg.Root()
	return Anchor_store_Params{root.Struct()}, err
}

func (s Anchor_store_Params) String() string {
	str, _ := text.Marshal(0x8ef1ac844ec73672, s.Struct)
	return str
}

func (s Anchor_store_Params) Value() (Value, error) {
	p, err := s.Struct.Ptr(0)
	return Value{Struct: p.Struct()}, err
}

func (s Anchor_store_Params) HasValue() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_store_Params) SetValue(v Value) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewValue sets the value field to a newly
// allocated Value struct, preferring placement in s's segment.
func (s Anchor_store_Params) NewValue() (Value, error) {
	ss, err := NewValue(s.Struct.Segment())
	if err != nil {
		return Value{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Anchor_store_Params_List is a list of Anchor_store_Params.
type Anchor_store_Params_List struct{ capnp.List }

// NewAnchor_store_Params creates a new list of Anchor_store_Params.
func NewAnchor_store_Params_List(s *capnp.Segment, sz int32) (Anchor_store_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_store_Params_List{l}, err
}

func (s Anchor_store_Params_List) At(i int) Anchor_store_Params {
	return Anchor_store_Params{s.List.Struct(i)}
}

func (s Anchor_store_Params_List) Set(i int, v Anchor_store_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_store_Params_List) String() string {
	str, _ := text.MarshalList(0x8ef1ac844ec73672, s.List)
	return str
}

// Anchor_store_Params_Future is a wrapper for a Anchor_store_Params promised by a client call.
type Anchor_store_Params_Future struct{ *capnp.Future }

func (p Anchor_store_Params_Future) Struct() (Anchor_store_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_store_Params{s}, err
}

func (p Anchor_store_Params_Future) Value() Value_Future {
	return Value_Future{Future: p.Future.Field(0, nil)}
}

type Anchor_store_Results struct{ capnp.Struct }

// Anchor_store_Results_TypeID is the unique identifier for the type Anchor_store_Results.
const Anchor_store_Results_TypeID = 0xc54940df263f58ae

func NewAnchor_store_Results(s *capnp.Segment) (Anchor_store_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_store_Results{st}, err
}

func NewRootAnchor_store_Results(s *capnp.Segment) (Anchor_store_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_store_Results{st}, err
}

func ReadRootAnchor_store_Results(msg *capnp.Message) (Anchor_store_Results, error) {
	root, err := msg.Root()
	return Anchor_store_Results{root.Struct()}, err
}

func (s Anchor_store_Results) String() string {
	str, _ := text.Marshal(0xc54940df263f58ae, s.Struct)
	return str
}

// Anchor_store_Results_List is a list of Anchor_store_Results.
type Anchor_store_Results_List struct{ capnp.List }

// NewAnchor_store_Results creates a new list of Anchor_store_Results.
func NewAnchor_store_Results_List(s *capnp.Segment, sz int32) (Anchor_store_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Anchor_store_Results_List{l}, err
}

func (s Anchor_store_Results_List) At(i int) Anchor_store_Results {
	return Anchor_store_Results{s.List.Struct(i)}
}

func (s Anchor_store_Results_List) Set(i int, v Anchor_store_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_store_Results_List) String() string {
	str, _ := text.MarshalList(0xc54940df263f58ae, s.List)
	return str
}

// Anchor_store_Results_Future is a wrapper for a Anchor_store_Results promised by a client call.
type Anchor_store_Results_Future struct{ *capnp.Future }

func (p Anchor_store_Results_Future) Struct() (Anchor_store_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_store_Results{s}, err
}

type Anchor_go_Params struct{ capnp.Struct }

// Anchor_go_Params_TypeID is the unique identifier for the type Anchor_go_Params.
const Anchor_go_Params_TypeID = 0xd3451f471503cf21

func NewAnchor_go_Params(s *capnp.Segment) (Anchor_go_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_go_Params{st}, err
}

func NewRootAnchor_go_Params(s *capnp.Segment) (Anchor_go_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_go_Params{st}, err
}

func ReadRootAnchor_go_Params(msg *capnp.Message) (Anchor_go_Params, error) {
	root, err := msg.Root()
	return Anchor_go_Params{root.Struct()}, err
}

func (s Anchor_go_Params) String() string {
	str, _ := text.Marshal(0xd3451f471503cf21, s.Struct)
	return str
}

func (s Anchor_go_Params) Args() (Value_List, error) {
	p, err := s.Struct.Ptr(0)
	return Value_List{List: p.List()}, err
}

func (s Anchor_go_Params) HasArgs() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_go_Params) SetArgs(v Value_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Value_List, preferring placement in s's segment.
func (s Anchor_go_Params) NewArgs(n int32) (Value_List, error) {
	l, err := NewValue_List(s.Struct.Segment(), n)
	if err != nil {
		return Value_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_go_Params_List is a list of Anchor_go_Params.
type Anchor_go_Params_List struct{ capnp.List }

// NewAnchor_go_Params creates a new list of Anchor_go_Params.
func NewAnchor_go_Params_List(s *capnp.Segment, sz int32) (Anchor_go_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_go_Params_List{l}, err
}

func (s Anchor_go_Params_List) At(i int) Anchor_go_Params { return Anchor_go_Params{s.List.Struct(i)} }

func (s Anchor_go_Params_List) Set(i int, v Anchor_go_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_go_Params_List) String() string {
	str, _ := text.MarshalList(0xd3451f471503cf21, s.List)
	return str
}

// Anchor_go_Params_Future is a wrapper for a Anchor_go_Params promised by a client call.
type Anchor_go_Params_Future struct{ *capnp.Future }

func (p Anchor_go_Params_Future) Struct() (Anchor_go_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_go_Params{s}, err
}

type Anchor_go_Results struct{ capnp.Struct }

// Anchor_go_Results_TypeID is the unique identifier for the type Anchor_go_Results.
const Anchor_go_Results_TypeID = 0x9fb80cccef72e8de

func NewAnchor_go_Results(s *capnp.Segment) (Anchor_go_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_go_Results{st}, err
}

func NewRootAnchor_go_Results(s *capnp.Segment) (Anchor_go_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_go_Results{st}, err
}

func ReadRootAnchor_go_Results(msg *capnp.Message) (Anchor_go_Results, error) {
	root, err := msg.Root()
	return Anchor_go_Results{root.Struct()}, err
}

func (s Anchor_go_Results) String() string {
	str, _ := text.Marshal(0x9fb80cccef72e8de, s.Struct)
	return str
}

func (s Anchor_go_Results) Proc() Proc {
	p, _ := s.Struct.Ptr(0)
	return Proc{Client: p.Interface().Client()}
}

func (s Anchor_go_Results) HasProc() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_go_Results) SetProc(v Proc) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Anchor_go_Results_List is a list of Anchor_go_Results.
type Anchor_go_Results_List struct{ capnp.List }

// NewAnchor_go_Results creates a new list of Anchor_go_Results.
func NewAnchor_go_Results_List(s *capnp.Segment, sz int32) (Anchor_go_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Anchor_go_Results_List{l}, err
}

func (s Anchor_go_Results_List) At(i int) Anchor_go_Results {
	return Anchor_go_Results{s.List.Struct(i)}
}

func (s Anchor_go_Results_List) Set(i int, v Anchor_go_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Anchor_go_Results_List) String() string {
	str, _ := text.MarshalList(0x9fb80cccef72e8de, s.List)
	return str
}

// Anchor_go_Results_Future is a wrapper for a Anchor_go_Results promised by a client call.
type Anchor_go_Results_Future struct{ *capnp.Future }

func (p Anchor_go_Results_Future) Struct() (Anchor_go_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_go_Results{s}, err
}

func (p Anchor_go_Results_Future) Proc() Proc {
	return Proc{Client: p.Future.Field(0, nil).Client()}
}

type Proc struct{ Client *capnp.Client }

// Proc_TypeID is the unique identifier for the type Proc.
const Proc_TypeID = 0xb561ad669b43cc65

func (c Proc) Wait(ctx context.Context, params func(Proc_wait_Params) error) (Proc_wait_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb561ad669b43cc65,
			MethodID:      0,
			InterfaceName: "api/api.capnp:Proc",
			MethodName:    "wait",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Proc_wait_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Proc_wait_Results_Future{Future: ans.Future()}, release
}

// A Proc_Server is a Proc with a local implementation.
type Proc_Server interface {
	Wait(context.Context, Proc_wait) error
}

// Proc_NewServer creates a new Server from an implementation of Proc_Server.
func Proc_NewServer(s Proc_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Proc_Methods(nil, s), s, c, policy)
}

// Proc_ServerToClient creates a new Client from an implementation of Proc_Server.
// The caller is responsible for calling Release on the returned Client.
func Proc_ServerToClient(s Proc_Server, policy *server.Policy) Proc {
	return Proc{Client: capnp.NewClient(Proc_NewServer(s, policy))}
}

// Proc_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Proc_Methods(methods []server.Method, s Proc_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb561ad669b43cc65,
			MethodID:      0,
			InterfaceName: "api/api.capnp:Proc",
			MethodName:    "wait",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Wait(ctx, Proc_wait{call})
		},
	})

	return methods
}

// Proc_wait holds the state for a server call to Proc.wait.
// See server.Call for documentation.
type Proc_wait struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Proc_wait) Args() Proc_wait_Params {
	return Proc_wait_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Proc_wait) AllocResults() (Proc_wait_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Proc_wait_Results{Struct: r}, err
}

type Proc_wait_Params struct{ capnp.Struct }

// Proc_wait_Params_TypeID is the unique identifier for the type Proc_wait_Params.
const Proc_wait_Params_TypeID = 0xd805d12cefe22b70

func NewProc_wait_Params(s *capnp.Segment) (Proc_wait_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Proc_wait_Params{st}, err
}

func NewRootProc_wait_Params(s *capnp.Segment) (Proc_wait_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Proc_wait_Params{st}, err
}

func ReadRootProc_wait_Params(msg *capnp.Message) (Proc_wait_Params, error) {
	root, err := msg.Root()
	return Proc_wait_Params{root.Struct()}, err
}

func (s Proc_wait_Params) String() string {
	str, _ := text.Marshal(0xd805d12cefe22b70, s.Struct)
	return str
}

// Proc_wait_Params_List is a list of Proc_wait_Params.
type Proc_wait_Params_List struct{ capnp.List }

// NewProc_wait_Params creates a new list of Proc_wait_Params.
func NewProc_wait_Params_List(s *capnp.Segment, sz int32) (Proc_wait_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Proc_wait_Params_List{l}, err
}

func (s Proc_wait_Params_List) At(i int) Proc_wait_Params { return Proc_wait_Params{s.List.Struct(i)} }

func (s Proc_wait_Params_List) Set(i int, v Proc_wait_Params) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Proc_wait_Params_List) String() string {
	str, _ := text.MarshalList(0xd805d12cefe22b70, s.List)
	return str
}

// Proc_wait_Params_Future is a wrapper for a Proc_wait_Params promised by a client call.
type Proc_wait_Params_Future struct{ *capnp.Future }

func (p Proc_wait_Params_Future) Struct() (Proc_wait_Params, error) {
	s, err := p.Future.Struct()
	return Proc_wait_Params{s}, err
}

type Proc_wait_Results struct{ capnp.Struct }

// Proc_wait_Results_TypeID is the unique identifier for the type Proc_wait_Results.
const Proc_wait_Results_TypeID = 0xcf49dc7714f7eebd

func NewProc_wait_Results(s *capnp.Segment) (Proc_wait_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Proc_wait_Results{st}, err
}

func NewRootProc_wait_Results(s *capnp.Segment) (Proc_wait_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Proc_wait_Results{st}, err
}

func ReadRootProc_wait_Results(msg *capnp.Message) (Proc_wait_Results, error) {
	root, err := msg.Root()
	return Proc_wait_Results{root.Struct()}, err
}

func (s Proc_wait_Results) String() string {
	str, _ := text.Marshal(0xcf49dc7714f7eebd, s.Struct)
	return str
}

// Proc_wait_Results_List is a list of Proc_wait_Results.
type Proc_wait_Results_List struct{ capnp.List }

// NewProc_wait_Results creates a new list of Proc_wait_Results.
func NewProc_wait_Results_List(s *capnp.Segment, sz int32) (Proc_wait_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Proc_wait_Results_List{l}, err
}

func (s Proc_wait_Results_List) At(i int) Proc_wait_Results {
	return Proc_wait_Results{s.List.Struct(i)}
}

func (s Proc_wait_Results_List) Set(i int, v Proc_wait_Results) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Proc_wait_Results_List) String() string {
	str, _ := text.MarshalList(0xcf49dc7714f7eebd, s.List)
	return str
}

// Proc_wait_Results_Future is a wrapper for a Proc_wait_Results promised by a client call.
type Proc_wait_Results_Future struct{ *capnp.Future }

func (p Proc_wait_Results_Future) Struct() (Proc_wait_Results, error) {
	s, err := p.Future.Struct()
	return Proc_wait_Results{s}, err
}

type Frac struct{ capnp.Struct }

// Frac_TypeID is the unique identifier for the type Frac.
const Frac_TypeID = 0xf84b0bdc2ebe874f

func NewFrac(s *capnp.Segment) (Frac, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Frac{st}, err
}

func NewRootFrac(s *capnp.Segment) (Frac, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Frac{st}, err
}

func ReadRootFrac(msg *capnp.Message) (Frac, error) {
	root, err := msg.Root()
	return Frac{root.Struct()}, err
}

func (s Frac) String() string {
	str, _ := text.Marshal(0xf84b0bdc2ebe874f, s.Struct)
	return str
}

func (s Frac) Numer() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Frac) HasNumer() bool {
	return s.Struct.HasPtr(0)
}

func (s Frac) SetNumer(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s Frac) Denom() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Frac) HasDenom() bool {
	return s.Struct.HasPtr(1)
}

func (s Frac) SetDenom(v []byte) error {
	return s.Struct.SetData(1, v)
}

// Frac_List is a list of Frac.
type Frac_List struct{ capnp.List }

// NewFrac creates a new list of Frac.
func NewFrac_List(s *capnp.Segment, sz int32) (Frac_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Frac_List{l}, err
}

func (s Frac_List) At(i int) Frac { return Frac{s.List.Struct(i)} }

func (s Frac_List) Set(i int, v Frac) error { return s.List.SetStruct(i, v.Struct) }

func (s Frac_List) String() string {
	str, _ := text.MarshalList(0xf84b0bdc2ebe874f, s.List)
	return str
}

// Frac_Future is a wrapper for a Frac promised by a client call.
type Frac_Future struct{ *capnp.Future }

func (p Frac_Future) Struct() (Frac, error) {
	s, err := p.Future.Struct()
	return Frac{s}, err
}

type LinkedList struct{ capnp.Struct }

// LinkedList_TypeID is the unique identifier for the type LinkedList.
const LinkedList_TypeID = 0xa683121d7d12cdc6

func NewLinkedList(s *capnp.Segment) (LinkedList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return LinkedList{st}, err
}

func NewRootLinkedList(s *capnp.Segment) (LinkedList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return LinkedList{st}, err
}

func ReadRootLinkedList(msg *capnp.Message) (LinkedList, error) {
	root, err := msg.Root()
	return LinkedList{root.Struct()}, err
}

func (s LinkedList) String() string {
	str, _ := text.Marshal(0xa683121d7d12cdc6, s.Struct)
	return str
}

func (s LinkedList) Count() uint32 {
	return s.Struct.Uint32(0)
}

func (s LinkedList) SetCount(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s LinkedList) Head() (Value, error) {
	p, err := s.Struct.Ptr(0)
	return Value{Struct: p.Struct()}, err
}

func (s LinkedList) HasHead() bool {
	return s.Struct.HasPtr(0)
}

func (s LinkedList) SetHead(v Value) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewHead sets the head field to a newly
// allocated Value struct, preferring placement in s's segment.
func (s LinkedList) NewHead() (Value, error) {
	ss, err := NewValue(s.Struct.Segment())
	if err != nil {
		return Value{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s LinkedList) Tail() (Value, error) {
	p, err := s.Struct.Ptr(1)
	return Value{Struct: p.Struct()}, err
}

func (s LinkedList) HasTail() bool {
	return s.Struct.HasPtr(1)
}

func (s LinkedList) SetTail(v Value) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewTail sets the tail field to a newly
// allocated Value struct, preferring placement in s's segment.
func (s LinkedList) NewTail() (Value, error) {
	ss, err := NewValue(s.Struct.Segment())
	if err != nil {
		return Value{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// LinkedList_List is a list of LinkedList.
type LinkedList_List struct{ capnp.List }

// NewLinkedList creates a new list of LinkedList.
func NewLinkedList_List(s *capnp.Segment, sz int32) (LinkedList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return LinkedList_List{l}, err
}

func (s LinkedList_List) At(i int) LinkedList { return LinkedList{s.List.Struct(i)} }

func (s LinkedList_List) Set(i int, v LinkedList) error { return s.List.SetStruct(i, v.Struct) }

func (s LinkedList_List) String() string {
	str, _ := text.MarshalList(0xa683121d7d12cdc6, s.List)
	return str
}

// LinkedList_Future is a wrapper for a LinkedList promised by a client call.
type LinkedList_Future struct{ *capnp.Future }

func (p LinkedList_Future) Struct() (LinkedList, error) {
	s, err := p.Future.Struct()
	return LinkedList{s}, err
}

func (p LinkedList_Future) Head() Value_Future {
	return Value_Future{Future: p.Future.Field(0, nil)}
}

func (p LinkedList_Future) Tail() Value_Future {
	return Value_Future{Future: p.Future.Field(1, nil)}
}

type Vector struct{ capnp.Struct }

// Vector_TypeID is the unique identifier for the type Vector.
const Vector_TypeID = 0xfbc39fed30ae733e

func NewVector(s *capnp.Segment) (Vector, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Vector{st}, err
}

func NewRootVector(s *capnp.Segment) (Vector, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Vector{st}, err
}

func ReadRootVector(msg *capnp.Message) (Vector, error) {
	root, err := msg.Root()
	return Vector{root.Struct()}, err
}

func (s Vector) String() string {
	str, _ := text.Marshal(0xfbc39fed30ae733e, s.Struct)
	return str
}

func (s Vector) Count() uint32 {
	return s.Struct.Uint32(0)
}

func (s Vector) SetCount(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s Vector) Shift() uint8 {
	return s.Struct.Uint8(4)
}

func (s Vector) SetShift(v uint8) {
	s.Struct.SetUint8(4, v)
}

func (s Vector) Root() (Vector_Node, error) {
	p, err := s.Struct.Ptr(0)
	return Vector_Node{Struct: p.Struct()}, err
}

func (s Vector) HasRoot() bool {
	return s.Struct.HasPtr(0)
}

func (s Vector) SetRoot(v Vector_Node) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRoot sets the root field to a newly
// allocated Vector_Node struct, preferring placement in s's segment.
func (s Vector) NewRoot() (Vector_Node, error) {
	ss, err := NewVector_Node(s.Struct.Segment())
	if err != nil {
		return Vector_Node{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Vector) Tail() (Value_List, error) {
	p, err := s.Struct.Ptr(1)
	return Value_List{List: p.List()}, err
}

func (s Vector) HasTail() bool {
	return s.Struct.HasPtr(1)
}

func (s Vector) SetTail(v Value_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewTail sets the tail field to a newly
// allocated Value_List, preferring placement in s's segment.
func (s Vector) NewTail(n int32) (Value_List, error) {
	l, err := NewValue_List(s.Struct.Segment(), n)
	if err != nil {
		return Value_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Vector_List is a list of Vector.
type Vector_List struct{ capnp.List }

// NewVector creates a new list of Vector.
func NewVector_List(s *capnp.Segment, sz int32) (Vector_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Vector_List{l}, err
}

func (s Vector_List) At(i int) Vector { return Vector{s.List.Struct(i)} }

func (s Vector_List) Set(i int, v Vector) error { return s.List.SetStruct(i, v.Struct) }

func (s Vector_List) String() string {
	str, _ := text.MarshalList(0xfbc39fed30ae733e, s.List)
	return str
}

// Vector_Future is a wrapper for a Vector promised by a client call.
type Vector_Future struct{ *capnp.Future }

func (p Vector_Future) Struct() (Vector, error) {
	s, err := p.Future.Struct()
	return Vector{s}, err
}

func (p Vector_Future) Root() Vector_Node_Future {
	return Vector_Node_Future{Future: p.Future.Field(0, nil)}
}

type Vector_Node struct{ capnp.Struct }
type Vector_Node_Which uint16

const (
	Vector_Node_Which_branches Vector_Node_Which = 0
	Vector_Node_Which_values   Vector_Node_Which = 1
)

func (w Vector_Node_Which) String() string {
	const s = "branchesvalues"
	switch w {
	case Vector_Node_Which_branches:
		return s[0:8]
	case Vector_Node_Which_values:
		return s[8:14]

	}
	return "Vector_Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Vector_Node_TypeID is the unique identifier for the type Vector_Node.
const Vector_Node_TypeID = 0x806044540cfc08ec

func NewVector_Node(s *capnp.Segment) (Vector_Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Vector_Node{st}, err
}

func NewRootVector_Node(s *capnp.Segment) (Vector_Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Vector_Node{st}, err
}

func ReadRootVector_Node(msg *capnp.Message) (Vector_Node, error) {
	root, err := msg.Root()
	return Vector_Node{root.Struct()}, err
}

func (s Vector_Node) String() string {
	str, _ := text.Marshal(0x806044540cfc08ec, s.Struct)
	return str
}

func (s Vector_Node) Which() Vector_Node_Which {
	return Vector_Node_Which(s.Struct.Uint16(0))
}
func (s Vector_Node) Branches() (Vector_Node_List, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != branches")
	}
	p, err := s.Struct.Ptr(0)
	return Vector_Node_List{List: p.List()}, err
}

func (s Vector_Node) HasBranches() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Vector_Node) SetBranches(v Vector_Node_List) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewBranches sets the branches field to a newly
// allocated Vector_Node_List, preferring placement in s's segment.
func (s Vector_Node) NewBranches(n int32) (Vector_Node_List, error) {
	s.Struct.SetUint16(0, 0)
	l, err := NewVector_Node_List(s.Struct.Segment(), n)
	if err != nil {
		return Vector_Node_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Vector_Node) Values() (Value_List, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != values")
	}
	p, err := s.Struct.Ptr(0)
	return Value_List{List: p.List()}, err
}

func (s Vector_Node) HasValues() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Vector_Node) SetValues(v Value_List) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewValues sets the values field to a newly
// allocated Value_List, preferring placement in s's segment.
func (s Vector_Node) NewValues(n int32) (Value_List, error) {
	s.Struct.SetUint16(0, 1)
	l, err := NewValue_List(s.Struct.Segment(), n)
	if err != nil {
		return Value_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Vector_Node_List is a list of Vector_Node.
type Vector_Node_List struct{ capnp.List }

// NewVector_Node creates a new list of Vector_Node.
func NewVector_Node_List(s *capnp.Segment, sz int32) (Vector_Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Vector_Node_List{l}, err
}

func (s Vector_Node_List) At(i int) Vector_Node { return Vector_Node{s.List.Struct(i)} }

func (s Vector_Node_List) Set(i int, v Vector_Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Vector_Node_List) String() string {
	str, _ := text.MarshalList(0x806044540cfc08ec, s.List)
	return str
}

// Vector_Node_Future is a wrapper for a Vector_Node promised by a client call.
type Vector_Node_Future struct{ *capnp.Future }

func (p Vector_Node_Future) Struct() (Vector_Node, error) {
	s, err := p.Future.Struct()
	return Vector_Node{s}, err
}

const schema_c8aa6d83e0c03a9d = "x\xda\x94V\x7f\x8c\x14w\x15\x7f\x9f\xef\xcc\xec\xdc\xde" +
	"\xee\xdd\xde\xf0\x1dR\xdb\x86\\4h\xda\xab\x9c\x14\x08" +
	"\x89\x17\xebn\x95\x03\xaf\"\xde\xb0-\xc1\xa41\xcc\xed" +
	"\xce\xddn\xd8\xdb9g\xf7\xb8\x10\xd3\xa8\xa1\x86\xbfj" +
	"R\x93F[\xd34\xad\xa9Q\x82\xb5M%\x81\xa6\x18" +
	"\xaa\xa5\xa2\xd2\xd4*5\x98P\xa5M\x89\xd8P\x01\xa5" +
	"\xe5\xa7|\xcd\x9b\xdd\x99Y\xf6\x8e\x16\xff\xdb\xfd~\xde" +
	"\xfb\xbc7\xdf\xf7\xde\xe7\xfb\x96_\xd6\x0a\xe2Nc]" +
	"\x0f\x91\xb3\xc5H\xa9S=W\xb2\xf7\xae\xd9\xf2mr" +
	"\x16\x03\xea\xf3\x8dg\x96\xbf\xf7\xc4o.\xd3(LA" +
	"$\xd3\xfa\x9f\xe4b\xdd$\x92\x96>GP\xc1\xea\xdf" +
	"nxp\xf7\xd9\xef\x91\xb5\x18D\x06L\xa2\x95\x0f\xeb" +
	"\x8b@\x90\x8f\xeay\x82:w\xff\x85\xcd\x1f\xeb_\xfb" +
	"H\xa7\xc1\xbe\x96\xc1K\xa1\xc1\xdfN\x06\xa7\x0fg\xf7" +
	">\xd1i\xf0\x96.\xd8\xe0Dh\xf0\xca\xab\x8b\x1eX" +
	"\xb2h\xc7O\xc8\xe9\x07\xd4\xe3#\x07\x8e\xef\x98\xdeu" +
	"\x88\x0c\xc1Y\x18\xc6\xef\xa5e\xf0\xaf>\xe3\x17\x04U" +
	"x\xf9\xca\xe4}\xe7\xd7\xff\xac\xc5\xc6\x89\xae|\xda\xe8" +
	"\x05\xe9\xea\xe6\xe1W~\xfa\xfd\x0f\xae<\xd7\x19\xe7!" +
	"\x86 \x1f18\xce\xb3\xb9\xaf\xffx\xf50\x9e\xef4" +
	"\xd8c\x84\x99\xee\x0f\x0d\xbc\xc3_\xfc\xd1\xe4\xcf\xdd=" +
	"d\xf5kI\x1e\x04\xf9\xa6\xf1\x98<\x11&\xf1\x96\xb1" +
	"N\xa6S&\x91z\xea\x0f\xdf|\xe0\xdd]\x9f}\x81" +
	"\xb3\x16\x89\xf5(\xcc\x01\"y\xd6xJ^d\x8f\x95" +
	"\xef\x1b;5\x82z\xf4\xcc\xf3\xfd\xdf\xb9u\xe9\xaf;" +
	"\x83?\x9e\x0eo\xe1\xc94\x07\x7ffs\xfeS\x7f/" +
	"\x8c\x1d\xec\xf8\xb07\xd2\xb7\xf0\x87\xed\xff\xd7y{\xee" +
	"\xd8\xd8kd\xc9\x08\xd9\xcf\x9e\xba\xfa\xf8k\xda\xe2u" +
	"\x83\xa3\x7f\xee \x95O\xa6/\x11\xe4\xd3!\xe7\xcc\x1d" +
	"o\x9f\xfe\xf4\xeb\xc6\xd1\xc4S\xbe\x91\xbeD\xbaZ\xf6" +
	"\xd0\xce\xb7g\xfer\xc7\xbb\xad\x1e\xd8xd\xc7\xab\xe2" +
	"\x85\xdd\xe7hT\x84=\xb0/}I\x1eL\xb3\xf5K" +
	"i\xbe\xf3\x1f\\\xbcZ\xbc\xf5\x87\x9bN'\xa9\xc9\xaf" +
	"\xf52M\xec\xd8}aw\xf5\xee\x92\xa3\xbd7\x11\xad" +
	"tz\xd7A\xde\x9c\xe1\x1b\xfb\xea\xce_\x0d\x1f\xcb|" +
	"\xf9\x02Y\xfd\xf3\xca\x8c\xccc2\x9d\x09\x0b\x9e\xe1\xb6" +
	"\x8b\xdbr\xa1\x9ep3\xbbd5s\x13\x91\xfcF\xe6" +
	"\x1f\xb4L\xb93\xd5\xcf\xb83\xd5aQrg\xea3" +
	"#\x9b\xbcR\xd3\x0f\x867\xf8ex\xe3\x80\xd3\xa3\xe9" +
	"Y\xa5t\x10Y\xb7\xdfC\xe4\xdc\xa6\xc1Y#\xd0\x87" +
	"\xab\xca\x06\x9f\xde=B\xe4|N\x83\xb3Y@M\x04" +
	"n\xbdT\xf1\x1aD\x84~\xc2\xb8\x06\x0c$3C\xe0" +
	"\xc3\xfc6\xb76\xeb5\x12<n\x86\x16\x1eg\xa4\xb5" +
	"2\xba\xbb^\xaa\xf8\xc1p\xa3\xe9\x07\xde\xd2q7p" +
	"\xa7\xd1ptM'\x0a\xb3\xea[A\xe4\xf4hpl" +
	"\x81\xc1\x90\xba\x8br\xe0\xba\x94snm\xeb\xd2\x8d^" +
	"c\xb6\xd6\xbc\x96r$\xa1\xcc\xbb\xa1-\xac\xa4^\x04" +
	"X\xd7\xe5\x9c\xf2\xdb\x8c\x0d\xead\x1cJ\x18s3\x81" +
	"_\x82\x95\x0cL\x17_\xbb\x10\xeb\xab\xf5\xad^y}" +
	"\xb5\xd1$\xe2Bdc\xb2Q\xfe\xe2\x82\x06g\xbd\x00" +
	"\xd0\xaa\xc2\x18\x07X\xa3\xc1\x19\x17\xb0\x04l\x08\"\xeb" +
	"+|\xf8%\x0d\xce\xbd\x02\x83%\x7f\xb6\xdeD\x0f\x09" +
	"\xf4\x10r\x15\xcf-\xcf\xbf\xa7\\\xd3\xad\xd6n\xf8\xfa" +
	"j\xbe[n\x15\xa4A\xf4aW\x1c\xd9\\\xf7B\xdc" +
	"f\x05Y\x12\xc8~x\xac\x85J\xf5\xffT\x1f-\xca" +
	"\xf1@\xf3K|\xa5\xbaf\x10\xc5s\x8eH*,k" +
	"\x88\x84e\x98\xb99\xb7\xda,`\x1c\xf3\x186\xb9f" +
	"m6\x1c\x8fB<\x1e\xf29|\x82\xa8\xb8\x1b\x1a\x8a" +
	"{\xd11!r\x0fF\x88\x8a\xcf2\xf0\"\x04\x96\x88" +
	"\xff\xaa\x81\xb0@r\x1f\x86\x88\x8a\xbfd\xe4\x00#\xda" +
	"\x15\x05\x1b\x1a\x91\xdc\x1f\x92\xede\xe4e&\xd3/+" +
	"\x1b:\x8bJH\xf6\"\x03\x87\xd8\xc5\xb8\xc4.\x06\x91" +
	"<\x18\xba\x1c`\xe40\xbb\xa4.*\x1b)\"\xf9;" +
	"\xdcCT<\xc4\xc0\x11\x06\xcc\x0b\xca\x0e\xd5\xee\xf50" +
	"\xfca\x06\x8e2W\xcfy%l\xf4\xb0\xd0\x85\xc8\x1f" +
	"\x199\xc6.\xe9\x0f\x94\x8d4\x91\xfck\x18\xe4\x08\x03" +
	"\xc7\x19\xe8}_\xd9\xe8%\x92o\xe2\x0bD\xc5\xa3\x0c" +
	"\xbc\xc3@\xe6\x9c\xb2\x91a\xd1\x0f\x13>\xc6\xc0I\x06" +
	"\xb2\xffQ6\xb2D\xf2D\x18\xe38\x03\xa7\x18\xe8\xfb" +
	"\xb7\xb2\xd1G$\xff\x19\x02\xef0p\x86\x81\xfe\xb3\xca" +
	"F?\x91|/\xa4:\xc9\xc09\x06rg\x94\x8d\x1c" +
	"?\x18\xa1\xc7)\x06.@\xc0\xacWk\x94\xca\xd7\xdd" +
	"fu\x9b\x175Vn\xc2\xf7k\x00\x09\x80`VW" +
	"\xaf\x82A\x02\x06!?Q\x9d\x1a\xab7\xd1G\x02}" +
	"\x04sr\xf5*dH CP\x13\xd5\xa9\xb55\xdf" +
	"m\xb2\x9eE<\x93\x81[\xc2@\"\xc8\xed\xd1)U" +
	"\xdc\x00:\x09\xe8\x04\xb3\xd1\x0c\"\xfbom\xf5\xb6\xcf" +
	"\xf9A9\xfa\x9fol\x9f\x9e\xf0k1]g\xf3\xe7" +
	"j\xd5F\x13\x03\xc9\xa3\xde\xe2\xceo\x0bE\x19\x03\x89" +
	"\xb2\xb7\x83~\x84\x94t\xcdPcAibU\xcfj" +
	"pn\x13P\xa5J\xb5V\x0e\xbc\xfa5\xfa\x1d\xbfw" +
	"7\xa0\xcfa\x00\xad\xd9\x88\x8dR\xd1\xcc\xf9\xa5a\x9e" +
	"\xa78\x85\xc8\xa0[=\xf3-\xb5XH+\x96\x0a\xe4" +
	"\xdc`\xea\x06\x9e\x0e\xd1\x1d\xb5\xcd\xdam\xd0\x0e[\x9c" +
	"\x9d\xc8\xb7~v)\xedP\xa2\xb4}Pj\xbe\xd6." +
	"\x11WU\xa4\xb6#\x89\xda^[\xd5\xc0\xf7\x9b\x94\xfa" +
	"\xe8\x97Dt\x97\xab;kD\x069\xb6pt )" +
	"\x8e\x85\x8d\xaa8;\x11:\x13\x02\xc7\x0e\xc5-\xda>" +
	"\x10\xadP\xd6\xc3\xb7\x90\xb0\xbek\x02\xf1\xce\x87h\x0b" +
	"\xb5\xb6\xb3\xf0M\x9b\x10\xf1\xa6\x88h\xef\xb3\\\xc6\xee" +
	"3\xa1\xc5[-\xa2\xad\xcb\x1a[A\xc2\xba\xcbD\xb2" +
	"T!Z\\\xad;9\xde'M\xad\xd6( \xc7\xcf" +
	"A\x019V\xf3\x02\x06\xc3\x96)@\x9b\xf2\x17T\xd9" +
	"\xb5\x81\xe6\x96\xda;H\xbb \xb7\xb3\xdc/\xd5\xe0," +
	"\x17\xb0\xa2\xb7o\xd9\x8a\xf6^\xb2J`\xb0>;\xed" +
	"\x05\xd1,\x0f\x96\xbd\xba?\x1d\xfd\x9b\xa7\xe2^\x8e\xc7" +
	"*\xbc\xc6xG\xb10\x94\xdb\xe0\x97=g \x0e\xea" +
	"2\xff\xfd\x1a\x9c\x0a\x07\xd5[A=>\xdc\xa2\xc1\xa9" +
	"\x09@\xb4:\xa0\xca\x8dQ\xd6\xe0\xcc\x08XZK\xc9" +
	"\xadi>\xachp\x1e\xec~\x84\x07\x1b\x95\xead\x13" +
	")\x12H\xb5\xbb\xa4k[\x8a\x9f\xe4\xeb5\xfc\xff\x02" +
	"\x00\x00\xff\xff\x9c\x1aJ~"

func init() {
	schemas.Register(schema_c8aa6d83e0c03a9d,
		0x806044540cfc08ec,
		0x8ef1ac844ec73672,
		0x95460e1858f85cf4,
		0x9fb80cccef72e8de,
		0xa683121d7d12cdc6,
		0xa94cf75566fcc440,
		0xb1fcf692a8c62e19,
		0xb3012e36a35e0fb0,
		0xb561ad669b43cc65,
		0xba39aaea7d7bcba2,
		0xc2241b810eb3f099,
		0xc54940df263f58ae,
		0xcf49dc7714f7eebd,
		0xd3451f471503cf21,
		0xd805d12cefe22b70,
		0xea2bd670e2878d2d,
		0xef56981b53fef997,
		0xf4acba02cd83d452,
		0xf84b0bdc2ebe874f,
		0xfbc39fed30ae733e)
}
