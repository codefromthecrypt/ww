// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/wetware/ww/pkg/boot (interfaces: Strategy,Beacon)

// Package mock_boot is a generated GoMock package.
package mock_boot

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	host "github.com/libp2p/go-libp2p-core/host"
	peer "github.com/libp2p/go-libp2p-core/peer"
	boot "github.com/wetware/ww/pkg/boot"
	reflect "reflect"
)

// MockStrategy is a mock of Strategy interface
type MockStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockStrategyMockRecorder
}

// MockStrategyMockRecorder is the mock recorder for MockStrategy
type MockStrategyMockRecorder struct {
	mock *MockStrategy
}

// NewMockStrategy creates a new mock instance
func NewMockStrategy(ctrl *gomock.Controller) *MockStrategy {
	mock := &MockStrategy{ctrl: ctrl}
	mock.recorder = &MockStrategyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStrategy) EXPECT() *MockStrategyMockRecorder {
	return m.recorder
}

// DiscoverPeers mocks base method
func (m *MockStrategy) DiscoverPeers(arg0 context.Context, arg1 ...boot.Option) (<-chan peer.AddrInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DiscoverPeers", varargs...)
	ret0, _ := ret[0].(<-chan peer.AddrInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiscoverPeers indicates an expected call of DiscoverPeers
func (mr *MockStrategyMockRecorder) DiscoverPeers(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscoverPeers", reflect.TypeOf((*MockStrategy)(nil).DiscoverPeers), varargs...)
}

// Loggable mocks base method
func (m *MockStrategy) Loggable() map[string]interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Loggable")
	ret0, _ := ret[0].(map[string]interface{})
	return ret0
}

// Loggable indicates an expected call of Loggable
func (mr *MockStrategyMockRecorder) Loggable() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Loggable", reflect.TypeOf((*MockStrategy)(nil).Loggable))
}

// MockBeacon is a mock of Beacon interface
type MockBeacon struct {
	ctrl     *gomock.Controller
	recorder *MockBeaconMockRecorder
}

// MockBeaconMockRecorder is the mock recorder for MockBeacon
type MockBeaconMockRecorder struct {
	mock *MockBeacon
}

// NewMockBeacon creates a new mock instance
func NewMockBeacon(ctrl *gomock.Controller) *MockBeacon {
	mock := &MockBeacon{ctrl: ctrl}
	mock.recorder = &MockBeaconMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBeacon) EXPECT() *MockBeaconMockRecorder {
	return m.recorder
}

// Loggable mocks base method
func (m *MockBeacon) Loggable() map[string]interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Loggable")
	ret0, _ := ret[0].(map[string]interface{})
	return ret0
}

// Loggable indicates an expected call of Loggable
func (mr *MockBeaconMockRecorder) Loggable() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Loggable", reflect.TypeOf((*MockBeacon)(nil).Loggable))
}

// Signal mocks base method
func (m *MockBeacon) Signal(arg0 context.Context, arg1 host.Host) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Signal", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Signal indicates an expected call of Signal
func (mr *MockBeaconMockRecorder) Signal(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Signal", reflect.TypeOf((*MockBeacon)(nil).Signal), arg0, arg1)
}

// Stop mocks base method
func (m *MockBeacon) Stop(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop
func (mr *MockBeaconMockRecorder) Stop(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockBeacon)(nil).Stop), arg0)
}
